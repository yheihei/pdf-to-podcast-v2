285 19章 アーキテクチャ決定 アーキテクトに求められることの1つに、アーキテクチャ決定がある。アーキテクチャ決定と は通常、アプリケーションやシステムの構造に関わる決定だ。しかし、何らかの技術的な決定が、 アーキテクチャ特性に影響を与える場合には、それもアーキテクチャ決定に含まれる。どのような 文脈であっても、優れたアーキテクチャ決定は、開発チームが適切な技術的選択を行うための指針 となる。アーキテクチャ決定を下す際は、関連情報を十分に集め、妥当性を示し、文書化し、そし て適切なステークホルダーに決定を効果的に伝えなくてはならない。 19.1 アーキテクチャ決定に関するアンチパターン アーキテクチャ決定を下すには技芸が求められる。驚くことではないが、アーキテクチャ決 定を下す際に現れるいくつかのアンチパターンが存在する。プログラマーのAndrew Koenig （https://oreil.ly/p9i_Y）は、アンチパターンのことを「始めたときは良いアイデアのように見え るが、トラブルにつながるもの」と定義している。また、アンチパターンには「ネガティブな結果 を生む、繰り返されるプロセス」という定義もある。アーキテクチャ決定を下す際に現れがちな 3つの主要なアンチパターンに、資産防御アンチパターン、グラウンドホッグデーアンチパターン、 メール駆動アーキテクチャアンチパターンがある。これら3つのアンチパターンは、通常、資産防 御アンチパターンの克服がグラウンドホッグデーアンチパターンに繋がり、グラウンドホッグデー アンチパターンの克服がメール駆動アーキテクチャアンチパターンに繋がるという、段階的な流れ を持っている。アーキテクトとして効果的で適切なアーキテクチャ決定を下すには、これら3つの アンチパターンをすべて克服する必要がある。 19.1.1 資産防御アンチパターン アーキテクチャ決定を下す際にまず現れるアンチパターンに、資産防御（CoveringYourAssets） アンチパターンがある。このアンチパターンは、選択を誤ることを恐れて、アーキテクチャ決定を 下すことを避けたり、先延ばししたりする場合に発生する。 資産防御アンチパターンを克服するには、2つの方法がある。1つ目は、重要なアーキテクチャ 286 19章 アーキテクチャ決定 決定を下すのを、最終責任時点†1まで先延ばしすることだ。これは、正当であると検証するのに十 分な情報が得られるまで、決定を先延ばしすることを意味している。ただし、開発チームを待たせ たり、分析麻痺アンチパターン†2に陥ったりするほど長くは決定を先延ばししてはならない。資 産防御アンチパターンを避ける2つ目の方法は、決定したことが期待通りに実装できるよう、開発 チームに継続的に協力することだ。これはとても重要だ。というのも、特定の技術やそれに関連す る問題の詳細を、アーキテクトだけですべて把握するのは不可能だからだ。開発チームと密に連携 することで、たとえ問題が発生しても、アーキテクトはアーキテクチャ決定を変更して、その問題 に迅速に対応できる。 この点を、次の例を使って説明しよう。製品に関する参照データ（製品の説明、重量、寸法）を、 その情報を必要とするすべてのサービスインスタンスにキャッシュすることを、アーキテクトが決 定したとする。プライマリのレプリカはカタログサービスが所有し、他のサービスは読み取り専用 のレプリケーションキャッシュを持つこととする。これは、製品情報に変更（または新製品の追加） があり、カタログサービスがその製品情報のキャッシュを更新すると、レプリケートされた（メモ リ内の）製品情報を通じて、そのデータを必要としている他のサービスすべてにその情報が反映さ れることを意味する。この決定の正当性は、サービス間の結合を減らし、サービス間呼び出しを行 うことなく効率的にデータを共有する点にある。しかし、このアーキテクチャ決定を元に実装を行 う開発チームは、一部のサービスのスケーラビリティ要件のために、この決定を満たすには、現在 よりもプロセスにより多くの仮想メモリを割り当てる必要があることに気がついた。開発チームと 密に連携することで、アーキテクトはこの問題を迅速に把握し、状況に対応できるようアーキテク チャ決定を調整できる。 19.1.2 グラウンドホッグデーアンチパターン アーキテクトが資産防御アンチパターンを克服してアーキテクチャ決定を下し始めると、 第二のアンチパターン、グラウンドホッグデーアンチパターンが現れる。グラウンドホッグデー （GroundhogDay）アンチパターンとは、ある決定が下された理由がわからずに、繰り返し何度も 議論されてしまうアンチパターンだ。このアンチパターンは、グラウンドホッグデー†3が催される 2月2日が何度も繰り返される、ビル・マーレイ主演の映画『恋はデジャ・ブ』（原題『Groundhog Day』）に由来している。 グラウンドホッグデーアンチパターンは、アーキテクトがアーキテクチャ決定を下した際に、そ の決定の根拠を示さないために発生する。アーキテクチャ決定の根拠を示す際には、技術的な理由 とビジネス的な理由の両方を提示することが重要だ。たとえば、アーキテクトは、モノリシックな アプリケーションを別々のサービスに分解して、アプリケーションを機能ごとに切り離すことで、 †1 訳注：決定を下しそこねると、重要な代替策がなくなる時点。 †2 訳注：過度に分析しすぎてしまい、意思決定が「麻痺」してしまい、解決策や行動方針が決まらないこと。 †3 訳注：アメリカ合衆国及びカナダにおいて2月2日に催される、ジリスの一種グラウンドホッグを使った春の訪れを予想する 天気占いの行事。 19.1 アーキテクチャ決定に関するアンチパターン 287 アプリケーションの各部分が使用する仮想マシンリソースを少なくし、別々に保守・デプロイでき るようにするという決定をすることがある。これは技術的な根拠の良い例だが、なぜこのアーキテ クチャのリファクタリングにお金をかける必要があるか、というような、ビジネス的な根拠が欠け ている。この決定のビジネス上の正当な理由としては、新しいビジネス機能をより早く提供するこ とで、市場投入までの時間を短縮できる点が考えられる。また、新機能の開発とリリースに関連す るコストを削減できるという理由も考えられる。 決定の根拠を示す際にビジネス価値を提示することは、どのようなアーキテクチャ決定であって も極めて重要だ。それはまた、そもそもそのアーキテクチャ決定を下すべきかどうかを判断するた めの良いリトマス試験でもある。あるアーキテクチャ決定がビジネス価値を提供しないのであれ ば、それはおそらく良い決定ではなく、再考されるべきだ。 最も一般的なビジネス上の根拠には、コスト、市場投入までの時間、ユーザー満足度、戦略的な ポジショニングの4つが挙げられる。これらの一般的なビジネス上の根拠に着目する場合、ビジネ スのステークホルダーにとって何が重要なのかを考慮することが重要だ。ある決定をコスト削減だ けに基づいて正当化することは、ビジネスのステークホルダーがコストをあまり気にしておらず、 市場投入までの時間をより重視している場合には、正しい決定ではないかもしれない。 19.1.3 メール駆動アーキテクチャアンチパターン アーキテクトが正当な根拠を持って決定を行うと、第三のアンチパターン、メール駆動アーキテ クチャアンチパターンが現れる。メール駆動アーキテクチャ（Email-DrivenArchitecture）アンチ パターンは、人々がアーキテクチャ決定を見失ったり、忘れたり、あるいは決定されたことさえ知 らなかったりするために、そのアーキテクチャ決定を実装できなくなってしまうというアンチパ ターンだ。このアンチパターンの肝は、アーキテクチャ決定を効果的に伝えているかどうかだ。電 子メールは確かにコミュニケーションのための素晴らしいツールだが、ドキュメントのリポジトリ システムとしては不十分なのだ。 アーキテクチャ決定をより効果的に伝え、それによってメール駆動アーキテクチャアンチパター ンを避ける方法はたくさんある。アーキテクチャ決定を伝える際の第一のルールは、「アーキテク チャ決定を電子メールの本文に含めない」だ。電子メールの本文にアーキテクチャ決定を含めてし まうと、その決定に関する複数の記録システムができてしまうことになる。多くの場合、重要な詳 細（なぜその決定が正当であるかを含む）は電子メールからは省かれてしまうため、グラウンド ホッグデーアンチパターンが繰り返されてしまう。また、そのアーキテクチャ決定が変更された り、置き換えられたりした場合、変更された決定を人々はどのように受け取るだろうか。より良い 方法は、電子メールの本文では決定の性質と文脈についてのみ言及し、実際のアーキテクチャ決定 とそれに対応する詳細は、それを記録した単一のシステムへのリンクにすることだ（それがWiki ページへのリンクであろうとファイルシステム内の文書であろうと構わない）。 アーキテクチャ決定を効果的に伝えるための第二のルールは、アーキテクチャ決定に本当に関心 のある人にだけ、それを伝えることだ。効果的なテクニックの1つは、メールの本文を次のように 288 19章 アーキテクチャ決定 書くことだ。 「こんにちは、Sandra。サービス間の通信に関する、あなたに直接影響のある重要な決定を行 いました。よければ、以下のリンクからその決定を参照してください。...」 「サービス間の通信に関する」という2文目の言い回しに注目してほしい。ここでは、決定の背景 が述べられているが、決定そのものについては述べられていない。文の後半部分「あなたに直接影 響のある」はさらに重要だ。アーキテクチャ決定が直接その人に影響を与えないのであれば、その 人はアーキテクチャ決定を気にする必要はない。これは、どのステークホルダー（開発者を含む） にアーキテクチャ決定を直接知らせるべきかを判断する際の素晴らしいリトマス試験だ。3文目で は、アーキテクチャ決定の記録場所へのリンクを提供している。これにより、アーキテクチャ決定 は一箇所にのみ存在し、そこがこの決定のための唯一の記録システムとなる。 19.2 アーキテクチャ上重要なもの アーキテクチャ決定に特定の技術が含まれる場合、アーキテクトは、それをアーキテクチャ決定 ではなく、技術的な決定だと考えてしまう傾向がある。しかし、それは必ずしも正しいとは言えな い。特定のアーキテクチャ特性（パフォーマンスやスケーラビリティなど）を直接サポートしてい るという理由で、アーキテクトがある技術を使うという決定を下した場合には、それはアーキテク チャ決定といえる。 著名なソフトウェアアーキテクトであり、『ReleaseIt!』（オーム社）[10]の著者でもあるMichael Nygard（https://www.michaelnygard.com）は、アーキテクチャ上重要なものという用語を用い て、アーキテクトが責任を持つべき決定とは何か（したがってアーキテクチャ決定とは何か）を明 らかにするという問題に取り組んでいる。Michaelによれば、アーキテクチャ上重要な決定とは、 構造、非機能特性、依存関係、インターフェイス、構築手法に影響を与える決定のことだ。 構造とは、使用されているアーキテクチャスタイルやアーキテクチャパターンに影響を与える決 定を指す。例としては、一連のマイクロサービス間でデータを共有するという決定がある。この決 定は、マイクロサービスの境界づけられたコンテキストに影響を与え、アプリケーションの構造に も影響を与える。 非機能特性とは、開発や保守の対象となるアプリケーションやシステムにとって重要なアーキテ クチャ特性（「イリティ」）のことだ。技術の選択がパフォーマンスに影響を与え、パフォーマンス がアプリケーションの重要な側面である場合、それはアーキテクチャ決定になる。 依存性とは、システム内のコンポーネントやサービス間の結合点のことで、全体的なスケーラビ リティ、モジュール性、アジリティ、テスト容易性、信頼性などに影響を与える。 インターフェイスとは、サービスやコンポーネントへのアクセスやオーケストレーションの方法 を指し、通常はゲートウェイ、統合ハブ、サービスバス、APIプロキシなどを介して行われる。イ 19.3 アーキテクチャデシジョンレコード 289 ンターフェイスには通常、コントラクトの定義が含まれ、そのコントラクトのバージョン管理や廃 止戦略なども含まれる。インターフェイスは、システムのユーザーに影響を与えるため、重要な アーキテクチャ決定といえる。 最後の構築手法とは、プラットフォーム、フレームワーク、ツール、さらにはプロセスに関する 決定であり、本質的には技術的な決定ではあるものの、アーキテクチャの何らかの側面に影響を与 えるような決定を指す。 19.3 アーキテクチャデシジョンレコード アーキテクチャ決定を文書化する最も効果的な方法の1つに、アーキテクチャデシジョンレコー ド（ArchitectureDecisionRecords、ADR）（https://adr.github.io）がある。ADRは、Michael Nygardがブログ記事（https://oreil.ly/yDcU2）で初めて紹介し、その後、ThoughtWorksテク ノロジーレーダー（https://oreil.ly/0nwHw。24章で詳しく取り上げる）で「採用」となるまでに なった。ADRは、特定のアーキテクチャ決定を記述した短いテキストファイル（通常は1〜2ペー ジ）で構成される。プレーンテキストで書いても良いが、通常はAsciiDoc（http://asciidoc.org） やMarkdown（https://www.markdownguide.org）などのフォーマットで記述される。Wikiペー ジのテンプレートを使って書くことも可能だ。 ADRを管理するためのツールも存在する。『実践テスト駆動開発 : テストに導かれてオブ ジェクト指向ソフトウェアを育てる』（翔泳社）[11]の共著者であるNatPryceは、ADR-tools （https://oreil.ly/6d8LN）というADR用のオープンソースツールを開発している。ADR-toolsは、 ADRを管理するためのコマンドラインインターフェイスを提供するもので、番号付け、配置、 置き換えロジックなどの機能を持っている。ドイツのソフトウェアエンジニアMichaKopsは、 ADR-toolsの使用方法をブログ記事（https://oreil.ly/OgBZK）にまとめており、アーキテクチャ デシジョンレコードを管理するためにADR-toolsをどのように使用できるかについて、いくつもの 素晴らしい例を示してくれている。 19.3.1 基本構造 ADRの基本構造は、タイトル、ステータス、コンテキスト、決定、影響という5つの主要セク ションから構成される。私たちは通常、基本構造の一部として、さらにコンプライアンスと備考と いう2つのセクションを追加する。この基本構造（図19-1）は、テンプレートの一貫性と簡潔さが 保たれていれば、必要に応じて他のセクションを含む形に拡張が可能だ。たとえば、必要に応じ て代替案セクションを追加して、可能なすべての代替ソリューションの分析を提供できる。 290 19章 アーキテクチャ決定 ADRフォーマット タイトル アーキテクチャ決定の簡単な説明 ステータス 提案済み、承認済み、破棄 コンテキスト この決定を行った状況 決定 決定とその根拠 影響 この決定による影響 コンプライアンス この決定が順守されていることを確認する方法 備考 この決定のメタデータ（著者など） 図19-1 基本的なADRの構造 19.3.1.1 タイトル ADRのタイトルには通常、連番が振られ、アーキテクチャ決定を説明する簡単なフレーズが含ま れる。たとえば、OrderサービスとPaymentサービスの間で非同期メッセージを使用するという 決定は、「42. OrderサービスとPaymentサービス間における非同期メッセージでの通信」といっ たタイトルになるだろう。タイトルは、決定の性質と文脈に対する曖昧さを十分取り除く程度には 説明的でなければならないと同時に、短く簡潔でなければならない。 19.3.1.2 ステータス ADRのステータスは、提案済み、承認済み、破棄のいずれかが提示される。提案済みステータス は、決定が上位の意思決定者、またはある種のアーキテクチャ管理機関（アーキテクチャレビュー ボードなど）によって承認されなければならないことを意味する。承認済みステータスは、決定が 承認され、実装の準備ができていることを意味する。破棄ステータスは、決定が変更され、別の ADRに取って代わられたことを意味する。提案済みADRが別のADRにとって代わられることは ない。提案済みADRは、受け入れられるまで変更され続ける。 破棄ステータスは、どのような決定がなされたのか、なぜその時になされたのか、新しい決定 は何なのか、なぜ変更されたのかを歴史的に記録しておくための強力な手段だ。通常、あるADR 19.3 アーキテクチャデシジョンレコード 291 が破棄された場合には、そのADRにとって代わった決定が記録される。同様に、他のADRに 取って代わった決定には、元のADRが記される。たとえば、それまではADR42（「Orderサービ スとPaymentサービス間における非同期メッセージでの通信」）が承認されていたが、その後の Paymentサービスの実装やデプロイ先の変更により、2つのサービス間ではRESTを使用しなけれ ばならなくなったとする（ADR68）。このときのステータスは次のようになる。 ADR42. OrderサービスとPaymentサービス間における非同期メッセージでの通信 ステータス：68に伴い破棄された ADR68. OrderサービスとPaymentサービス間におけるRESTでの通信 ステータス：承認済み。42を破棄した ADR42と68の間のリンクと履歴があることで、ADR68に関して避けられない「非同期メッセー ジを使ったらどうですか？」という質問を回避できる。 ADRとコメント募集（RFC） アーキテクトがADRのドラフトを送付してコメントを求めたい場合（たとえば、アーキテ クトがより多くのステークホルダーとさまざまな仮定や主張を検証したい場合には、コメント を求めるのが適している場合がある）、コメント募集（またはRFC（RequestforComments）） という名前の新しいステータスを作成して、そのレビューが完了する期限日を指定することを お勧めする。これにより、いつまでも議論して決定ができないという分析麻痺アンチパターン を避けられる。期限が来たなら、アーキテクトはADRに寄せられたすべてのコメントを分析 し、決定に必要な調整をし、そして最終的な決定を行い、ステータスを提案済みに設定でき る（アーキテクト自身が決定を承認できる場合には、ステータスは承認済みに設定される）。 ADRのRFCステータスの例を次に示す。 ステータス コメント募集。期限は2010年1月9日 ADRのステータスセクションのもう一つの重要な側面には、アーキテクトがアーキテクチャ決 定を自分で承認できる基準や、より上位のアーキテクトやアーキテクチャレビューボードなどの アーキテクチャ管理機関による承認が必要かどうかについて、自分の上司やリードアーキテクトと 必要な会話をさせることがある。 そうした会話を始めるのに適した3つの基準は、コスト、チーム間の影響、セキュリティだ。コ ストには、ソフトウェアの購入費やライセンス料、追加のハードウェア費用のほか、アーキテク 292 19章 アーキテクチャ決定 チャ決定を実装するための全体的な努力レベルが含まれる。努力レベルのコストは、アーキテク チャ決定の実装にかかる推定時間に、会社の標準的なフルタイム当量（FTE）†4を乗算することで 見積もりが可能だ。通常はプロジェクトオーナーかプロジェクトマネージャーがFTE率を把握し ている。アーキテクチャ決定のコストが一定額を超える場合は、そのアーキテクチャ決定を提案済 みステータスに設定し、他の誰かに承認してもらう必要がある。アーキテクチャ決定が他のチーム やシステムに影響を与えたり、何らかのセキュリティ上の意味合いを持つ場合も、アーキテクトの 自己承認ではなく、より上位の管理機関かリードアーキテクトに承認を得る必要がある。 基準とそれに対応する制限が確立・合意されたら（「5,000ユーロを超えるコストはアーキテク チャ審査委員会の承認を受けなければならない」など）、この基準をしっかりと文書化し、ADRを 作成するすべてのアーキテクトが、自分のアーキテクチャ決定をいつ承認できて、いつ承認できな いのかがわかるようにしなければならない。 19.3.1.3 コンテキスト ADRのコンテキストセクションでは、どのような力学が作用しているかを明らかにする。言い 換えれば、「どのような状況でこの決断を迫られているのか」ということだ。ADRのこのセクショ ンでは、アーキテクトは具体的な状況や問題点を説明し、可能な代替案を簡潔に説明する。アーキ テクトが各代替案の分析を詳細に文書化する必要がある場合には、その分析をコンテキストセク ションに追加するのではなく、ADRに代替案セクションを追加できる。 コンテキストセクションはまた、アーキテクチャを文書化する方法でもある。コンテキストを記 述することで、アーキテクトはアーキテクチャも記述することになる。これは、アーキテクチャの 特定の領域を明確かつ簡潔な方法で文書化する効果的な方法だ。前節の例を続けるなら、コンテキ ストは次のようになるかもしれない。「Orderサービスは、現在発注されている注文の決済を行う ために、Paymentサービスに情報を渡さなければならない。これはRESTまたは非同期メッセージ を使用して行える」。この簡潔な文はシナリオだけでなく、代替案も指定している。 19.3.1.4 決定 ADRの決定セクションには、アーキテクチャ決定がその完全な正当性とともに記述される。 MichaelNygardは、受動的にではなく、非常に肯定的かつ命令的な形でアーキテクチャ決定を述 べる素晴らしい方法を紹介した。たとえば、サービス間で非同期メッセージを使用するという決定 は、「サービス間に非同期メッセージを使用する」と記述する。これは、「サービス間に用いるのは 非同期メッセージが最善の選択肢だと思う」という記述とは対照的に、意思決定を表すのにとても 良い表現だ。後者の例では、決定が何なのか、あるいは決定がなされたのかどうかすら明確でな く、アーキテクトの意見が述べられているだけになってしまうことに注意しよう。 ADRの決定セクションの最も強力な側面には、アーキテクトがHowよりもWhyに重点を置ける †4 訳注：1人のフルタイム社員が処理できる仕事量のこと。 19.3 アーキテクチャデシジョンレコード 293 という点がある。ある決定がなされた理由を理解することは、何かがどう機能するかを理解するこ とよりもはるかに重要だ。ほとんどのアーキテクトや開発者は、コンテキスト図を見れば物事がど のように機能するかを特定できる。しかし、なぜその決定がなされたのかは図だけでは特定できな い。ある決定がなされた理由と、その決定に対応する正当な理由を知ることは、問題のコンテキス トをよりよく理解するのに役立ち、問題が発生する可能性のある別のソリューションへのリファク タリングによるミスを回避することに繋がる。 この点を説明するために、2つのサービス間の通信手段としてGoogleのリモートプロシージャ コール（gRPC）（https://www.grpc.io）を使用するという最初のアーキテクチャ決定が数年前に あったとしてみよう。その決定の理由を理解しないまま、数年後に別のアーキテクトがその決定に 変わってメッセージングを使用してサービスをよりよく分離するという選択をしたとする。しか し、このリファクタリングを行ったところ、突如としてレイテンシーが大幅に増加し、結果的に上 流のシステムでタイムアウトが発生してしまった。gRPCの本来の使用目的が、実は（サービスが 密結合になるという代償を払っても）レイテンシーを大幅に削減することにあったということを理 解していたなら、そもそもリファクタリングを行わないで済んだはずだ。 19.3.1.5 影響 ADRの影響セクションも非常に強力なセクションだ。このセクションでは、アーキテクチャ決 定の全体的な影響を文書化する。アーキテクトが行うすべてのアーキテクチャ決定には、良くも悪 くも何らかの影響がある。アーキテクチャ決定の影響を明らかにする必要があることで、アーキテ クトは、その影響が決定の利点を上回っていないかを見極めなくてはならない。 このセクションのもう1つの良い使い方は、アーキテクチャ決定に関連するトレードオフ分析を 文書化することだ。これらのトレードオフは、コストベースのものであったり、他のアーキテク チャ上の特性（「イリティ」）とのトレードオフであったりする。たとえば、Webサイトにレビュー を投稿するために非同期（ファイア・アンド・フォーゲット）メッセージングを使用するという 決定を考えてみよう。この決定が正当な理由は、レビューが実際に投稿されるまでユーザーは待 つ必要がないことにある（メッセージがキューに送られるのを待つだけで十分）。これにより、レ ビュー投稿リクエストの応答性を3,100ミリ秒から25ミリ秒へと大幅に向上させられる。これは 正当な理由だが、非同期リクエストに関連するエラー処理が複雑になるために、これは良くないア イデアだと主張する人がいるかもしれない（「誰かが汚い言葉でレビューを投稿したらどうなるの か？」）。だが、この決定に異議を唱えている人には知られていないが、この問題はすでにビジネス のステークホルダーや他のアーキテクトと議論されていた。レビューが正常に投稿されたという フィードバックを同期的にユーザーに提供するための待ち時間よりも、応答性の向上と複雑なエ ラー処理に対処することの方が重要であるということが、トレードオフの観点から判断されていた のだ。ADRを活用することで、このトレードオフ分析を影響セクションに含められ、アーキテク チャ決定のコンテキスト（とトレードオフ）の全体像を提供し、このような状況を回避できる。 294 19章 アーキテクチャ決定 19.3.1.6 コンプライアンス ADRのコンプライアンスセクションは、ADRの標準セクションの1つではないが、私たちは追 加することを強くお勧めしているセクションだ。このセクションは、アーキテクチャ決定をどのよ うに評価し、アーキテクチャ決定を順守するという観点からどのように統制すべきかをアーキテク トに考える機会を提供する。アーキテクトは、この決定が順守されていることのチェックを手動で 行うのか、それとも適応度関数を使って自動化できるかを決めなければならない。適応度関数を使 用して自動化できる場合、アーキテクトはこのセクションで、その適応度関数がどのように書かれ るか、また、アーキテクチャ決定の順守を計測するためにコードベースに他の変更が必要かどうか を指定できる。 たとえば、図19-2に示すような、よくあるn層のレイヤードアーキテクチャでの、「ビジネス層 のビジネスオブジェクトが使用するすべての共有オブジェクトは、共有機能を格納しておく共有の サービス層に分離する」というアーキテクチャ決定を考えてみよう。 閉鎖 プレゼンテーション層 レイヤー 閉鎖 コンポーネント コンポーネント ビジネス層 レイヤー 開放 コンポーネント サービス層 レイヤー 閉鎖 永続化層 レイヤー 閉鎖 データベース層 レイヤー 図19-2 アーキテクチャ決定の例 このアーキテクチャ決定は、JavaのArchUnit（https://www.archunit.org）かC#のNetArchTest （https://oreil.ly/0J5fN）を使用することで、自動的に評価・管理できる。たとえば、JavaのArchUnit を使うと、自動化された適応度関数テストは次のようになる。 @Test public void shared_services_should_reside_in_services_layer() { 19.3 アーキテクチャデシジョンレコード 295 classes().that().areAnnotatedWith(SharedService.class) .should().resideInAPackage("..services..") .because("All shared services classes used by business " + "objects in the business layer should reside in the services " + "layer to isolate and contain shared logic") .check(myClasses); } この自動化された適応度関数を実際に使用するには、新しく Java アノテーション （@SharedService）を作成し、そのアノテーションをすべての共有クラスに追加する作業が 必要となる。コンプライアンスセクションでは、テストの内容、テスト箇所、テストの実行方法な どを記述する。 19.3.1.7 備考 標準のADRには含まれないものの、追加を強くお勧めするもう1つのセクションが「備考」セク ションだ。このセクションには、ADRに関するさまざまなメタデータが含まれている。 ● オリジナルの著者 ● 承認日 ● 承認者 ● 置き換え日 ● 最終更新日 ● 変更点 ● 最終更新内容 ADRをバージョン管理システム（Gitなど）に保存する場合でも、追加のメタ情報はリポジトリ がサポートできる範囲を超えて便利なため、ADRを保存する方法や場所に関わらず、このセクショ ンを追加することをお勧めする。 19.3.2 ADRを保存する アーキテクトがADRを作成したら、それをどこかに保存する必要がある。ADRをどこに保存す るかによらず、アーキテクチャ決定は個別のファイルやWikiページを持つべきだ。アーキテクト の中には、ADRをソースコードと一緒にGitリポジトリに保管することを好む人もいる。ADRを Gitリポジトリに保管することで、ADRのバージョン管理や追跡が可能になる。しかし、大規模な 組織では、いくつかの理由からこの方法には注意が必要だ。第一に、アーキテクチャ決定を見る必 要のある人全員が、Gitリポジトリにアクセスできるとは限らない。第二に、アプリケーションの コンテキストを外れたADR（統合アーキテクチャ決定、エンタープライズアーキテクチャ決定、す べてのアプリケーションに共通する決定など）を保管するのにGitリポジトリは適していない。こ 296 19章 アーキテクチャ決定 れらの理由から、ADRをWiki（Wikiテンプレートを使用）に保存するか、Wikiや他のドキュメン トレンダリングソフトウェアから簡単にアクセスできる共有ファイルサーバーの共有ディレクトリ に保存することをお勧めする。図19-3は、このディレクトリ構造（またはWikiページのナビゲー ション構造）がどのようになるかの例を示している。 architecture decisions application common atp pstd integration enterprise 図19-3 ADRを保存するためのディレクトリ構造の例 applicationディレクトリには、アプリケーションコンテキストに固有のアーキテクチャ決定が含 まれている。このディレクトリは、さらに細分化されている。commonサブディレクトリには、す べてのアプリケーションに適用されるアーキテクチャ決定が含まれている。たとえば「すべてのフ レームワーク関連のクラスには、基礎となるフレームワークコードに属するクラスを識別するアノ テーション（Javaでは@Framework）または属性（C#では[Framework]）が含まれる」などだ。 applicationディレクトリの下のサブディレクトリは、特定のアプリケーションやシステムのコンテ キストに対応していて、そのアプリケーションやシステムに固有のアーキテクチャ決定を含む（こ の例では、ATPとPSTDのアプリケーション）。integrationディレクトリには、アプリケーション、 システム、サービス間通信に関わるADRが含まれる。enterpriseディレクトリには、エンタープラ イズアーキテクチャADRが含まれる。エンタープライズアーキテクチャADRは、すべてのシステ ムとアプリケーションに影響を与えるグローバルなアーキテクチャ決定だ。エンタープライズアー キテクチャADRの例は、「システムデータベースへのすべてのアクセスは、所有しているシステム からのものに限られる」などだ。このADRによって、複数のシステム間でのデータベースの共有 19.3 アーキテクチャデシジョンレコード 297 を防げる。 私たちが推奨するように、ADRをWikiに保存する場合は、前述と同じ構造を適用し、各ディレ クトリ構造はナビゲーションランディングページを表すようにする。各ADRは、各ナビゲーショ ンランディングページ（アプリケーション、統合、エンタープライズ）内の1つのWikiページとし て表現される。 この節で紹介しているディレクトリやランディングページの名称は、あくまでも推奨だ。各企業 は、チーム間で一貫した名前であれば、それぞれの状況に合った名前を選択してほしい。 19.3.3 ドキュメントとしてのADR ソフトウェアアーキテクチャの文書化は、常に難しいテーマだ。ソフトウェアアーキテクト であるSimon BrownのC4モデル（https://c4model.com）やThe Open GroupのArchiMate （https://oreil.ly/gbNQG）標準など、アーキテクチャを図解するための規格がいくつか出ている ものの、ソフトウェアアーキテクチャを文書化するための標準は存在していない。そこでADRの 出番だ。 アーキテクチャデシジョンレコードは、ソフトウェアアーキテクチャを文書化するための効果的 な手段として使用できる。ADRのコンテキストセクションは、アーキテクチャ決定を必要とする システムの特定領域を記述する絶好の機会を提供する。このセクションはまた、代替案を記述する 機会を提供する。おそらくさらに重要なのは、決定セクションに特定の決定がなされた理由を記述 することであり、これはアーキテクチャの文書化の中でも最も優れた形式だ。影響セクションは アーキテクチャ文書の最後のピースで、スケーラビリティよりもパフォーマンスを選択する際のト レードオフ分析など、特定の決定の追加的な側面を記述する。 19.3.4 標準のためにADRを用いる 標準が好きな人はほとんどいない。標準は、役に立つからというより、人ややり方をコントロー ルするために用意されていると感じる場合がほとんどだからだ。ADRを活用することで、この悪 しき慣習を変えられる。たとえば、ADRのコンテキストセクションでは、特定の標準を強制する状 況を説明する。ADRの決定セクションは、標準が何であるかを示すだけでなく、さらに重要なこ ととして、なぜ標準が存在しなければならないのかを示すために使用できる。これは、その標準が そもそも存在すべきかを確認する優れた方法だ。アーキテクトがその標準を正当化できないのであ れば、おそらくその標準は作ったり適用したりするのに適した標準ではないのかもしれない。さら に、ある標準が存在する理由を理解すればするほど、開発者はそれに従う可能性は高くなる（それ に応じて異議を唱えなくなる）。ADRの影響セクションは、標準が正当であるか、策定すべきかど うかをアーキテクトが判断するもう1つの重要な場所だ。このセクションでは、アーキテクトは、 自分が作ろうとしている標準の意味合いや結果を考え、文書化しなければならない。結果を分析す ることで、アーキテクトは、その標準は結局適用すべきでないと判断するかもしれない。 298 19章 アーキテクチャ決定 19.3.5 事例 現在進行中のp.97「7.2.1 事例：Going、Going、Gone」の中には、多くのアーキテクチャ決定 が存在している。イベント駆動なマイクロサービスの使用、入札者とオークション参加者のユー ザーインターフェイスの分割、ビデオキャプチャのためのリアルタイムトランスポートプロトコル （RTP）の使用、単一のAPI層の使用、パブリッシュ／サブスクライブ型のメッセージングの使用 は、このオークションシステムのために行われた数十のアーキテクチャ決定のほんの一部だ。シス テムで行われるすべてのアーキテクチャ決定は、どんなに明白であっても、文書化され、根拠が示 されなければならない。 図19-4は、Going、Going、Goneオークションシステムにおけるアーキテクチャ決定の1つ、 BidCaptureサービス、BidStreamerサービス、BidTrackerサービス間でパブリッシュ／サブ スクライブ（Pub／Sub）型メッセージングを使用する例を示している。 入札 落札者 Bid Bid Bid Capture Streamer Tracker サービス サービス サービス Bids 入札サービス間で Pub／Subメッセージングを使用する 図19-4 サービス間にPub／Subメッセージングを使用する このアーキテクチャ決定についてのADRを図19-5に示す。 19.3 アーキテクチャデシジョンレコード 299 ADR 76. 入札サービス間での非同期Pub／Subメッセージング ステータス 承認済み コンテキスト BidCaptureサービスは、オンライン入札者または競売人経由のライブ入札者からの入札を受信す ると、その入札をBidStreamerサービスとBidTrackerサービスに転送する必要がある。これには、 非同期ポイントツーポイント（P2P）メッセージングか非同期パブリッシュ／サブスクライブ（Pub ／Sub）メッセージング、あるいはオンラインオークションAPI層を介したRESTが使用できる。 決定 BidCaptureサービス、BidStreamerサービス、BidTrackerサービス間では、非同期のPub／ Subメッセージングを使用する。 BidCaptureサービスは、BidStreamerサービスやBidTrackerサービスから情報を受け取る必要 はない。 BidStreamerサービスは、BidCaptureサービスが受け付けた順番通りに入札を受け取らなけれ ばならない。メッセージングやキューを使用することで、ストリームの入札順が自動的に保証される。 非同期のPub／Subメッセージングを使用することで、入札プロセスのパフォーマンスを向上させ、 入札情報の拡張性を高められる。 影響 メッセージキューのクラスタリングと高可用性が必要になる。 内部の入札イベントは、API層で行われるセキュリティチェックをバイパスする。 更新：2020年4月12日のアーキテクチャ審査委員会（ARB）会議で検討した結果、ARBは、こ れは受け入れ可能なトレードオフであり、これらのサービス間の入札イベントに追加のセキュリティ チェックは必要ないと決定した。 コンプライアンス 定期的にコードレビューと設計レビューを手動で行って、BidCaptureサービス、BidStreamer サービス、BidTrackerサービス間で非同期のPub／Subメッセージングが使用されていることを確 認する。 備考 著者：スバシーニ・ナデラ 承認：ARB会議メンバー、2020年4月14日 最終更新日：2020年4月15日（最終更新者：スバシーニ・ナデラ） 図19-5 ADR76. 入札サービス間の非同期Pub／Subメッセージング 301 20章 アーキテクチャ上のリスクを 分析する すべてのアーキテクチャには、可用性、スケーラビリティ、データ完全性などに関するリスクが ある。アーキテクチャのリスクを分析することは、アーキテクチャに関する重要な活動の1つだ。 リスクを継続的に分析することで、アーキテクトはアーキテクチャ内の欠陥に対処し、リスクを軽 減する措置を取れる。この章では、リスクを限定し、リスクアセスメントを作成し、リスクストー ミングを通してリスクを特定していくための主要なテクニックとプラクティスを紹介する。 20.1 リスクマトリックス アーキテクチャのリスクを評価する際に最初に発生する問題は、リスクを高・中・低どれに分 類すべきかを決定することだ。通常、こういったリスク評価には主観が多く入り込む。そのため、 アーキテクチャのどの部分のリスクが本当に高く、どのリスクが中程度なのかについて混乱が生じ てしまう。幸いなことに、アーキテクトはリスクマトリックスを活用することで、主観の度合いを 減らし、アーキテクチャの個別の領域に関連するリスクを限定できる。 アーキテクチャのためのリスクマトリックス（図20-1）では、リスクの全体的な影響度とそのリ スクが発生する可能性という2つの側面を用いてリスクを限定する。それぞれの側面には、低（1）、 中（2）、高（3）の評価がある。これらの数値をマトリックスの各グリッド内で掛け合わせること で、そのリスクを表す客観的な数値が得られる。1〜2は低リスク（緑）、3〜4は中リスク（黄色）、 6〜9は高リスク（赤）とされている。 リスクマトリックスの使用方法を見ていこう。アプリケーションで使用する中央のプライマリ データベースについて、可用性の懸念があるとする。アーキテクトはまず、影響度について考え る。データベースがダウンしたり、利用できなくなったりした場合の全体的な影響はどの程度にな るだろうか。アーキテクトは、その影響度は高いと判断し、リスクを3（中）、6（高）、9（高）の どれかと評価する。しかし、次の側面（リスクが発生する可能性）を考えると、データベースはク ラスター化され可用性の高いサーバー上に構築されていることから、データベースが利用できなく なる可能性は低いことに気づく。そうすると、影響度の高さと可能性の低さの交点から、総合的な リスク評価は3（中リスク）となる。 302 20章 アーキテクチャ上のリスクを分析する リスク発生の可能性 低 (1) 中 (2) 高 (3) リ ス 低 1 2 3 ク (1) の 全 体 中 2 4 6 的 (2) な 影 響 高 3 6 9 (3) 図20-1 アーキテクチャリスクを設定するためのマトリックス リスクマトリックスを活用してリスクを限定する際には、まず影響度を考慮し、次に可能性を 考慮しよう。 20.2 リスクアセスメント 前節で説明したリスクマトリックスは、リスクアセスメントを構築するために使用できる。リス クアセスメントとは、ある種のコンテキストに沿った重要な何らかの評価基準に照らし合わせて、 アーキテクチャの全体的なリスクをまとめたレポートだ。 リスクアセスメントの内容は非常にさまざまだが、一般的には、アプリケーションのサービス やドメイン領域に基づいた評価基準に関するリスクが記される（これらはリスクマトリックスに よって限定される）。リスクアセスメントの基本的なレポート形式を図20-2に示す。薄い色のもの （1〜2）が低リスク、中くらいの濃さのもの（3〜4）が中リスク、濃い色のもの（6〜9）が高リス クとなっている。これらは通常、緑（低）、黄色（中）、赤（高）のように色分けされるが、白黒の レンダリングや色覚異常の方向けには濃淡で示す方が有効だ。 リスクマトリックスで定量化されたリスクは、リスク基準ごとだけでなく、サービスやドメイン 領域ごとにも累計される。たとえば、図20-2では、データ完全性に関するリスクの累計は17と最 も高いリスク領域であるのに対し、可用性に関するリスクの累計はわずか10（最も少ないリスク 量）となっている。各ドメイン領域の相対的なリスクは、リスクアセスメントの例で判断できる。 ここでは、顧客登録が最もリスクの高い領域であるのに対し、注文処理が最もリスクの低い領域と なっている。これらの相対的な数値を追跡することで、特定のリスクカテゴリーまたはドメイン領 域でのリスクの改善や低下を追える。 20.2 リスクアセスメント 303 カタログ リスク リスク基準 顧客登録 注文処理 発送処理 チェックアウト 合計 2 6 1 2 11 スケーラビリティ 3 4 2 1 10 可用性 4 2 3 6 15 パフォーマンス 6 3 1 1 11 セキュリティ 9 6 1 1 17 データ完全性 24 21 8 11 リスク合計 図20-2 標準的なリスクアセスメント例 図20-2のリスクアセスメント例には、リスク分析の全結果が含まれている。しかし、実際には そのようにすべての結果が表示されることはほとんどない。あるコンテキストで特定のメッセー ジを視覚的に示す際には、フィルタリングが不可欠だからだ。アーキテクトがシステムのリスクが 高い領域を提示する目的で会議に参加しているとする。その際には、リスク評価を図20-2のよう に提示するのではなく、図20-3のようにリスクの高い部分のみをフィルタリングして示すことで、 全体のS/N比を向上させ、システムの状態（良いか悪いか）を明確に提示できる。 カタログ リスク リスク基準 顧客登録 注文処理 発送処理 チェックアウト 合計 6 6 スケーラビリティ 0 可用性 6 6 パフォーマンス 6 6 セキュリティ 9 6 15 データ完全性 15 12 0 6 リスク合計 図20-3 リスク評価を高リスクのもののみにフィルタリング 304 20章 アーキテクチャ上のリスクを分析する 図20-2のもう1つの問題点は、この評価レポートがある時点でのスナップショットでしかないと いう点がある。この評価レポートは、状況が改善しているのか悪化しているのかを示していない。 つまり、図20-2では、リスクの方向が示されていない。リスクの方向を表現するには、ちょっと した問題がある。方向を示すのに上矢印や下矢印を使うとしたら、上矢印は何を意味するのだろう か。状況は良くなっているのか、それとも悪くなっているのか。私たちは何年にもわたって、上向 きの矢印が状況が良くなっていることを意味するのか、それとも悪くなっていることを意味するの かを人々に尋ねてきた。すると、およそ半分の人々が上向きの矢印は物事が徐々に悪くなっている ことを意味すると答え、およそ半分の人々が上向きの矢印は物事が良くなっていることを意味する と答えた。これは左右の矢印についても同じことが言える。このため、矢印を使って方向を表現す るときには、凡例を示す必要がある。しかし、これもうまくいかないことがわかった。ユーザーが 凡例のある位置を超えてスクロールすると、再び混乱が生じてしまうからだ。 私たちは、図20-4に示すように、リスク評価の横にプラス（＋）とマイナス（−）という普遍的 な方向記号を使って方向を示すようにしている。図20-4では、顧客登録のパフォーマンスは中程 度（4）となっているものの、方向はマイナス記号（赤）となっている。そのため、顧客登録のパ フォーマンスが徐々に悪化して高リスクに向かっていることがわかる。一方で、カタログチェック アウトのスケーラビリティは高く（6）、方向はプラス（緑）となっている。これによって、カタロ グチェックアウトのスケーラビリティは改善していっていることがわかる。プラスもマイナスもな いリスク評価は、リスクが安定しており、良くも悪くもなっていないことを示している。 カタログ リスク リスク基準 顧客登録 注文処理 発送処理 チェックアウト 合計 2 6 1 2 11 スケーラビリティ 3 4 2 1 10 可用性 4 2 3 6 15 パフォーマンス 6 3 1 1 11 セキュリティ 9 6 1 1 17 データ完全性 24 21 8 11 リスク合計 図20-4 リスクの方向をプラスとマイナスで示す 時には、プラスとマイナスの記号でさえも人を混乱させる。方向を示すもう1つのテクニック は、矢印とその矢印が向かっているリスク評価の数値を一緒に示すことだ。この手法は、図20-5 20.3 リスクストーミング 305 のように方向がはっきりとするため、凡例を必要としない。さらに、色を使うことで（悪いものは 赤矢印、良いものは緑矢印）、リスクの方向がより明確になる。 カタログ リスク リスク基準 顧客登録 注文処理 発送処理 チェックアウト 合計 4 2 6 1 2 11 スケーラビリティ 3 4 2 1 10 可用性 3 1 4 4 2 3 6 15 パフォーマンス 6 4 6 3 1 1 11 セキュリティ 9 6 9 6 1 1 17 データ完全性 9 2 24 21 8 11 リスク合計 図20-5 矢印と数値でリスクの方向を示す リスクの方向は、先に述べた適応度関数による継続的な計測を用いて判断できる。各リスク基準 を客観的に分析することで、傾向を観察し、各リスク基準の方向を把握できる。 20.3 リスクストーミング アーキテクトが単独でシステムの全体的なリスクを決定することはできない。一人ではリスク領 域を見落とす可能性があるし、システムのすべての部分について完全な知識を持っているアーキテ クトはほとんどいないからだ。そこで役に立つのが、リスクストーミングだ。 リスクストーミングとは、特定の側面におけるアーキテクチャのリスクを判断するための共同作 業だ。一般的な側面（リスク領域）には、実証されていない技術、パフォーマンス、スケーラビリ ティ、可用性（推移的な依存関係を含む）、データロス、単一障害点、セキュリティなどがある。リ スクストーミングには複数のアーキテクトが参加することが多いが、シニア開発者やテックリード にも参加してもらうのが良い。そうすることで、参加した開発者のアーキテクチャに対する理解が 深まるだけでなく、アーキテクチャのリスクに対して実装面での視点も得られるからだ。 リスクストーミングには、個人作業と共同作業の両方がある。個人作業では、参加者全員が、前 節で紹介したリスクマトリックスを使って（共同作業なしに）アーキテクチャの領域にリスクを割 り当てる。この個人作業は、他の参加者の影響を受けず、また特定の領域への注意が逸れないよう に、リスクを検討するという意味で重要だ。リスクストーミングの共同作業では、参加者全員が協 306 20章 アーキテクチャ上のリスクを分析する 力して、リスク領域に関する合意を形成し、リスクについて議論し、リスクを軽減するための解決 策を検討する。 アーキテクチャ図は、リスクストーミングの個人作業と共同作業の両方で使用される。全体的な リスク評価には、通常、包括的なアーキテクチャ図を使用し、アプリケーションの特定の領域にお けるリスクストーミングには、コンテキストに応じたアーキテクチャ図を使用する。リスクストー ミングを行うアーキテクトは、これらの図が最新であり、すべての参加者が利用可能であるように する責任がある。 リスクストーミングのプロセスを説明するのに使用するアーキテクチャ例を図20-6に示す。こ のアーキテクチャでは、Webサーバー（Nginx）とアプリケーションサービスを含む各EC2インス タンスの前に、ELB（ElasticLoadBalancer）が配置されている。アプリケーションサービスは、 MySQLデータベース、Redisキャッシュ、ログを記録するためのMongoDBデータベースを呼び 出すと共に、Push拡張サーバーへの呼び出しも行う。拡張サーバーには、MySQLデータベース、 Redisキャッシュ、MongoDBロギング機能すべてとのインターフェイスがある。 ELB EC2インスタンス群 Webサーバー (Nginx) アプリケーション アプリケーション アプリケーション Push サービス サービス サービス 拡張サーバー iOS Push Redis MongoDB MySQL キャッシュ ロギング 配信サーバー データベース Android Push 配信サーバー 図20-6 リスクストーミングに用いるアーキテクチャ図 リスクストーミングは、主に3つのアクティビティに分かれている。 20.3 リスクストーミング 307 1. 特定 2. 合意 3. 軽減 特定は個人で行い、合意と軽減は共同で行う。合意と軽減は、参加者全員が（最低限、仮想上で も）同じ部屋で一緒に作業する。次に、これらの主要アクティビティについて詳しく説明する。 20.3.1 特定 リスクストーミングの特定アクティビティでは、アーキテクチャ内のリスク領域を各参加者が 個々に特定する。リスクストーミングの特定アクティビティのステップは次のように行う。 1. リスクストーミングを実施するアーキテクトは、共同作業の1〜2日前に、すべての参加者に招 待状を送る。招待状には、アーキテクチャ図（またはそれを入手できる場所）、リスクストー ミングの側面（リスクストーミングで分析するリスク領域）、リスクストーミングの共同作業 をする日付、場所が含まれている。 2. 本章の最初の節で説明したリスクマトリックスを用いて、参加者は個々にアーキテクチャを分 析し、リスクを低（1〜2）、中（3〜4）、高（6〜9）に分類する。 3. 参加者は、対応する色（緑、黄、赤）の小さな付箋を用意し、対応するリスク番号（リスクマ トリックスに記載）を書き留める。 ほとんどのリスクストーミングでは、1回に1つの側面（パフォーマンスなど）のみを分析する が、参加者の都合やタイミングの問題で一度のリスクストーミングで複数の側面（パフォーマン ス、スケーラビリティ、データロスなど）を分析する場合もある。一度のリスクストーミングで複 数の側面を分析する場合には、参加者は、付箋でリスク番号の隣に側面を書き、分析している側面 を全員が認識できるようにする。たとえば、3人の参加者が中央データベースのリスクを発見した とする。3人ともリスクが高い（6）と認識したが、1人が発見したのは可用性に関するリスクで あったのに対し、残りの2人が発見したのはパフォーマンスに関するリスクだった。その場合、こ の2つの側面は別々に議論される必要がある。 可能な限り、リスクストーミングでは1度に1つの側面にのみ取り組むようにする。これによ り、参加者はその特定の側面に注意を集中でき、同じ領域に存在する別の側面のリスクが混 ざってしまうという混乱を避けられる。 20.3.2 合意 リスクストーミングの合意アクティビティは、アーキテクチャ内のリスクに関して、参加者全員 の合意を形成することを目的とした、高度な共同活動だ。このアクティビティでは、大きく印刷さ 308 20章 アーキテクチャ上のリスクを分析する れたアーキテクチャ図を用意して壁に貼っておくのが最も効果的だ。印刷された大きな紙の代わり に、電子版を大きなスクリーンに表示しても良いだろう。 リスクストーミングを開始すると、参加者は、アーキテクチャ図のリスクを発見した箇所に付箋 を貼り始める。電子版を使用する場合は、リスクストーミングを実施するアーキテクトが参加者 全員に問い合わせ、アーキテクチャ図上のリスクが特定された領域に電子的にリスクを配置する （図20-7）。 3 6 ELB 3 EC2インスタンス群 Webサーバー (Nginx) 9 アプリケーション アプリケーション アプリケーション Push サービス サービス サービス 拡張サーバー 2 9 2 3 iOS Push Redis MongoDB MySQL キャッシュ ロギング 2 配信サーバー 3 データベース 3 Android Push 配信サーバー 図20-7 リスク領域の初回特定 付箋がすべて出(cid:7975)ったら、リスクストーミングの共同作業を開始できる。リスクストーミングに おけるこのアクティビティの目標は、チームとしてリスク領域を分析し、リスクの適格性について の合意を形成することにある。ここで特定された、いくつかのリスク領域を図20-7に示す。 1. ELBを2名の参加者が中リスク（3）、1名の参加者が高リスク（6）と認識していた。 2. プッシュ拡張サーバーを1名の参加者が高リスク（9）と認識していた。 3. MySQLデータベースを3名の参加者が中リスク（3）と認識していた。 4. Redisキャッシュを1名の参加者が高リスク（9）と認識していた。 5. MongoDBのログを3名の参加者が低リスク（2）と認識していた。 20.3 リスクストーミング 309 6. アーキテクチャの他のすべての領域はリスクがないとみなされた。そのため、アーキテクチャ の他の領域には付箋は貼られていない。 前述のリストの項目3と項目5は、参加者全員でリスクのレベルと適格性の同意が得られたので、 このアクティビティでさらに議論をする必要はない。しかし、リストの項目1には意見の相違があ り、項目2と項目4はリスクを特定した参加者が1名しかいなかった。これらの項目については、 このアクティビティで議論する必要がある。 リストの項目1では、2人の参加者がELBを中程度のリスク（3）と認識しているのに対し、1名 の参加者が高リスク（6）と認識している。この場合、2人の参加者の側が3人目の参加者に、なぜ リスクが高いと判断したのかを尋ねる。3人目の参加者が「ELBがダウンするとシステム全体にア クセスできなくなるので、高リスクとした」と答えたとしよう。これは事実であり、実際に発生し た場合の全体的な影響度は高い。しかし、2人の参加者が「そのようなことが起こるリスクは低い」 と3人目の参加者を説得する。議論を重ねた結果、3人目の参加者はこれに同意し、リスクレベル を中程度（3）に引き下げた。とはいえ、2名の参加者は、3人目の参加者ほどELBのリスク側面を 見ていなかったかもしれない。そのため、リスクストーミングのこのアクティビティは共同で行う 必要がある。 共同で行うことが良いことを示す例を続けよう。1名の参加者だけがPush拡張サーバーを高リ スク（9）と認識し、他の参加者はリスクがまったくないとしていた。この場合は、リスクを特定 した参加者に他の参加者が「なぜリスクが高いと評価したのか」を尋ねる。その参加者は、高負荷 時にPush拡張サーバーが継続的にダウンするという悪い経験をしたことがあり、それはこの特定 のアーキテクチャが持っているものだと答えたとする。この例は、リスクストーミングの価値を示 している。もしこの参加者が参加していなければ、誰もその高いリスクに気づくことはなかっただ ろう（もちろん、本番運用が始まればいやでも気づくことにはなる）。 リストの項目4は興味深い事例だ。ある参加者はRedisキャッシュを高リスク（9）と認識してい た。しかし、他の参加者はそのキャッシュをアーキテクチャ上のリスクと認識していなかった。他 の参加者がRedisキャッシュのリスクが高い根拠は何かと尋ねると、その参加者は「Redisキャッ シュが何か知らないんだ」と答えた。この場合では、Redisがその参加者にとって未知のものであ るために、その領域のリスクを高く評価したというわけだ。 実証されていない技術や未知の技術については、リスクマトリックスを使用できないため、常 に高リスクの評価（9）を割り当てよう。 リストの項目4の例は、リスクストーミングのセッションに開発者を参加させることがなぜ賢明 （かつ重要）かを示している。その理由は、アーキテクチャについて開発者がより深く知れるだけ ではない。参加者の一人（この場合はチームの開発者）が特定の技術を知らなかったという事実 310 20章 アーキテクチャ上のリスクを分析する が、全体的なリスクを評価する際の貴重な情報になることがあるのだ。 このプロセスは、参加者全員が特定されたリスク領域に同意するまで続ける。すべての付箋を集 約し終えたら、このアクティビティは終了となり、次のアクティビティを開始できる。ここでのア クティビティの最終的な結果は、図20-8のようになった。 3 6 ELB EC2インスタンス群 Webサーバー (Nginx) 9 アプリケーション アプリケーション アプリケーション Push サービス サービス サービス 拡張サーバー 9 2 3 iOS Push Redis MongoDB MySQL キャッシュ ロギング 配信サーバー データベース Android Push 配信サーバー 図20-8 リスク領域の合意 20.3.3 軽減 参加者全員がアーキテクチャのリスク領域の適格性に合意したなら、最後の、そして最も重要な アクティビティであるリスクの軽減を行う。アーキテクチャのリスクを軽減するには、通常、そこ 以外は完璧だったかもしれないアーキテクチャの特定の領域を変更または強化する必要がある。 このアクティビティは通常、共同で行われ、最初のアクティビティで特定されたリスクを軽減ま たは排除する方法を模索する。リスクの特定に基づいて、元のアーキテクチャを完全に変更する必 要がある場合もあれば、スループットのボトルネック問題を軽減するためにバックプレッシャー用 のキューを追加するといった、単純なアーキテクチャのリファクタリングで済む場合もある。 アーキテクチャの変更が必要かに関わらず、このアクティビティには通常、追加コストが発生す る。そのため、主要なステークホルダーは、そのコストがリスクを上回るかどうかを判断すること 20.5 リスクストーミング例 311 になる。たとえば、リスクストーミングを通じて、中央データベースがシステム全体の可用性に関 して中程度のリスク（4）があると認識されたとする。この場合、参加者は、データベースをクラ スタリングし、単一のデータベースを別々の物理データベースに分割することで、そのリスクを軽 減することに同意した。しかし、リスクが大幅に軽減される一方、そのソリューションには20,000 ドルの追加コストがかかる。アーキテクトは、このトレードオフについて議論するため、主要なビ ジネスステークホルダーとのミーティングを実施する。この話し合いの中で、ビジネスオーナー は、コストが高すぎて、リスクを上回っていないと判断する。そこで、アーキテクトは諦めるので はなくて、クラスター化をやめてデータベースを2つに分割する案を提案する。この場合、コスト は8,000ドルに削減され、リスクも大幅に軽減される。ここでは、ステークホルダーはその案に同 意した。 前述のシナリオは、リスクストーミングがアーキテクチャ全体だけでなく、アーキテクトとビジ ネスステークホルダーとの調整にも影響を与えることを示している。リスクストーミングは、本章 の冒頭で説明したリスク評価と組み合わせることで、リスクを特定して追跡し、アーキテクチャを 改善し、主要なステークホルダー間の調整をまとめるための優れた手段となる。 20.4 ユーザーストーリーリスク分析 リスクストーミングは、アーキテクチャ以外のソフトウェア開発の側面にも利用できる。たとえ ば、私たちは、ユーザーストーリーを手入れする際に、与えられたイテレーション内でユーザース トーリーを完成させることに対する全体的なリスク（と、結果的にそのイテレーションの全体的な リスク評価）を見るために、リスクストーミングを活用した。リスクマトリックスを使用すると、 ユーザーストーリーのリスクは、イテレーション中にストーリーが完成しなかった場合の全体的 な影響という側面と、ストーリーが完成しない可能性という側面によって特定できる。アーキテク チャと同様、ストーリーにもリスクマトリックスを利用することで、チームはリスクの高いストー リーを特定し、それらを注意深く追跡し、優先順位をつけられる。 20.5 リスクストーミング例 リスクストーミングの効果と、それによってシステムの全体的なアーキテクチャがどのように改 善できるかを説明するために、さまざまな健康状態について患者にアドバイスをする看護師をサ ポートするコールセンターシステムの例を考えてみよう。このシステムの要件は次の通りだ。 312 20章 アーキテクチャ上のリスクを分析する ● このシステムでは、サードパーティ製の診断エンジンを使用して、医療問題に関する質問や 案内を看護師や患者に提供する。 ● 患者は、コールセンターに電話して看護師と話すか、看護師を介さずに診断エンジンに直接 アクセスするセルフサービスのWebサイトを利用できる。 ● このシステムは、全国250人の看護師と最大数十万人のセルフサービスの患者の同時接続を サポートする必要がある。 ● 看護師はカルテ交換システムを通じて患者のカルテにアクセスできるが、患者は自分のカル テにはアクセスできない。 ● システムは、カルテに関してHIPAA†1に準拠していなければならない。つまり、看護師以 外の者がカルテにアクセスできないようにすることが不可欠だ。 ● 風邪やインフルエンザのアウトブレイクや大量発生に対応する必要がある。 ● どの看護師に電話を回すかは、看護師のプロフィールに基づいている（バイリンガルの必要 性など）。 ● サードパーティの診断エンジンは、1秒間に約500件のリクエストを処理できる。 システムのアーキテクトは、図20-9に示すような高レベルなアーキテクチャを作成した。この アーキテクチャには、3つの独立したWebベースのユーザーインターフェイスがある。1つはセル フサービス用、もう1つは電話を受ける看護師用、もう1つは管理スタッフが看護師のプロフィー ルや設定を追加・変更するためのものだ。システムのコールセンター部分は、電話を受け取るコー ルアクセプターと、プロフィールに基づいて次の対応可能な看護師に電話をルーティングするコー ルルーターで構成されている（コールルーターは看護師のプロフィール情報を取得するために中央 データベースにアクセスする）。このアーキテクチャの中心にあるのは、診断システムのAPIゲー トウェイだ。APIゲートウェイは、セキュリティチェックを行い、適切なバックエンドサービスに リクエストを送る。 このシステムには、症例管理サービス、看護師プロフィール管理サービス、カルテ交換へのイン ターフェイス、外部サードパーティ診断エンジンという4つの主要サービスがある。外部システム とコールセンターサービスへの独自プロトコルを除き、すべての通信はRESTを使用している。 アーキテクトはこのアーキテクチャを何度も見直し、実装の準備ができていると考えている。自 己評価として、図20-9の要件とアーキテクチャ図を検討し、可用性、弾力性、セキュリティの観 点から、このアーキテクチャにおけるリスクレベルを決定してみよう。リスクレベルを決定した後 は、そのリスクを軽減するためにアーキテクチャにどのような変更が必要かを決定する。ここから は、比較対象となるシナリオを紹介する。 †1 訳注：HealthInsurancePortabilityandAccountabilityAct（医療保険の携行性と責任に関する法律）の略。アメリカの DHHS（保険社会福祉省）によって策定された健康情報に関するプライバシールール及びセキュリティルール。 20.5 リスクストーミング例 313 看護師向け 管理者向け セルフサービス用 コール UI UI Webアプリ アクセプター {REST} {REST} {REST} {専用回線} {専用回線} 診断システムAPIゲートウェイ（クラスター化されたインスタンス群） 認証システム {REST} {REST} {REST} {REST} コール 看護師 カルテ交換 診断エンジン 症例管理 ルーター プロフィール管理 インターフェイス インターフェイス {専用回線} {専用回線} 中央 データベース 外部カルテ交換 外部サードパーティ 診断エンジン 看護師プロフィール 症例メモ 図20-9 看護師診断システムのための高レベルアーキテクチャの例 20.5.1 可用性 最初のリスクストーミングでは、このシステムの成功には可用性が不可欠であることから、アー キテクトはまず可用性に焦点を当てることにした。リスクストーミングの特定と共同作業の後、参 加者はリスクマトリックスを用いて次のリスク領域を考え出した（図20-10）。 ● 中央データベースの使用は、影響度が高（3）、可能性が中程度（2）のため、高リスク（6） と判断した。 ● 診断エンジンの可用性については、影響度が高（3）、可能性が不明（3）のため、高リスク （9）と判断した。 ● カルテ交換の可用性は、システムの動作に必要なコンポーネントではないため、低リスク （2）と判断した。 ● システムのその他の部分は、各サービスの複数インスタンス化やAPIゲートウェイのクラス タリングにより、可用性のリスクはないと判断した。 リスクストーミングの中で、データベースが停止すると、看護師は手動で症例メモを書き留め ておけるものの、コールルーターは機能できなくなってしまうという点で参加者全員が合意した。 データベースのリスクを軽減するため、参加者は1つの物理データベースを2つの別々のデータ ベースに分割することを選択した。1つは看護師のプロフィール情報を含むクラスター化された データベースで、もう1つは症例メモ用のシングルインスタンスのデータベースだ。このアーキテ クチャの変更は、データベースの可用性に関する懸念の解消だけでなく、管理者のアクセスから症 314 20章 アーキテクチャ上のリスクを分析する 看護師向け 管理者向け セルフサービス用 コール UI UI Webアプリ アクセプター {REST} {REST} {REST} {専用回線} {専用回線} 診断システムAPIゲートウェイ（クラスター化されたインスタンス群） 認証システム {REST} {REST} {REST} {REST} コール 看護師 カルテ交換 診断エンジン 症例管理 ルーター プロフィール管理 インターフェイス インターフェイス {専用回線} {専用回線} 2 9 6 中央 データベース 外部カルテ交換 外部サードパーティ 診断エンジン 看護師プロフィール 症例メモ 図20-10 可用性のリスク領域 例ノートを保護するのにも役立った。このリスクを軽減する方法には、看護師プロフィール情報を コールルーターにキャッシュするというものもあった。しかし、コールルーターの実装が不明であ り、サードパーティ製品である可能性もあったため、参加者はデータベースのアプローチを採用 した。 外部システム（診断エンジンやカルテ交換）はコントロールができないため、可用性リスクを軽 減するのはずっと難しい。このような場合に可用性リスクを軽減するには、それぞれのシステムに ついて、サービスレベル契約（SLA）やサービスレベル目標（SLO）が公表されているかを調査す るという方法がある。通常、SLAは契約上の合意であり法的拘束力があるが、SLOには法的拘束力 はない。アーキテクトは調査に基づいて、診断エンジンのSLAは99.99%の可用性が保証されてお り（これは年間52.60分のダウンタイムに相当する）、カルテ交換は99.9%の可用性が保証されてい る（これは年間8.77時間のダウンタイムに相当）ことがわかった。相対的なリスクに基づいて、こ の情報は特定されたリスクを取り除くのに十分だった。 このリスクストーミングを反映して行われたアーキテクチャの変更を、図20-11に示す。2つ のデータベースが使用されるようになり、SLAもアーキテクチャ図上で公開されるようになって いる。 20.5 リスクストーミング例 315 看護師向け 管理者向け セルフサービス用 コール UI UI Webアプリ アクセプター {REST} {REST} {REST} {専用回線} {専用回線} 診断システムAPIゲートウェイ（クラスター化されたインスタンス群） 認証システム {REST} {REST} {REST} {REST} コール 看護師 カルテ交換 診断エンジン 症例管理 ルーター プロフィール管理 インターフェイス インターフェイス {専用回線} {専用回線} 看護師 プロフィールDB 症例DB 外部サードパーティ 外部カルテ交換 診断エンジン 看護師 症例メモ プロフィール SLA: 99.9% SLA: 99.99% 可用性 可用性 図20-11 可用性リスクに対応するためのアーキテクチャ変更 20.5.2 弾力性 2回目のリスクストーミングでは、アーキテクトはユーザー負荷の弾力性（弾力的なスケーラビ リティとも呼ばれる）に焦点を当てることにした。看護師の数は250人程度（看護師にはほとんど のサービスの自動制御を提供している）だが、看護師だけでなく、診断エンジンにはシステムのセ ルフサービス部分もアクセスできる。そのため、診断インターフェイスへのリクエスト数が大幅に 増加した。参加者は、システムへの予想される負荷が大幅に増加するアウトブレイクやインフルエ ンザの時期を懸念していた。 リスクストーミングでは、参加者全員が診断エンジンインターフェイスを高リスクと認識してい た（9）。1秒間に500回のリクエストしかないことから、参加者は、特にインターフェイスプロト コルとしてRESTを使用している現在のアーキテクチャでは、診断エンジンインターフェイスが予 想されるスループットに追いつくことはできないと計算した。 このリスクを軽減する1つの方法は、APIゲートウェイと診断エンジンインターフェイスとの 間で非同期キュー（メッセージング）を活用し、診断エンジンへの呼び出しが滞った場合のバッ クプレッシャー起点を提供することだ。これは良い方法だが、まだリスクを軽減できない。なぜ なら、看護師（およびセルフサービスの患者）は、診断エンジンからの応答を長時間待つことに なり、これらのリクエストがタイムアウトしてしまう可能性があるからだ。Ambulanceパターン （https://oreil.ly/ZfLU0）として知られているパターンを活用すると、セルフサービスよりも看護 師を優先できるものの、2つのメッセージチャンネルが必要になる。この手法はリスクを軽減する のに役立つが、待ち時間の問題にはまだ対応できていない。参加者は、バックプレッシャーを提供 316 20章 アーキテクチャ上のリスクを分析する するためのキューイング技術に加えて、アウトブレイクに関連する特定の診断質問をキャッシュす ることで、アウトブレイクやインフルエンザの際の電話が診断エンジンのインターフェイスに到達 することを無くせると判断した。 これに対応するアーキテクチャの変更を図20-12に示す。2つのキューチャンネル（1つは看護 師用、もう1つはセルフサービスの患者用）に加えて、特定のアウトブレイクやインフルエンザ関 連の質問に関連したすべてのリクエストを処理する診断アウトブレイクキャッシュと呼ばれる新し いサービスを用意している。このアーキテクチャを採用することで、制限要因（診断エンジンへの 呼び出し）が取り除かれ、数万件の同時リクエストが可能になった。リスクストーミングを行わな ければ、アウトブレイクが発生したりインフルエンザの季節になるまで、このリスクは特定されな かったかもしれない。 看護師向け 管理者向け セルフサービス用 コール UI UI Webアプリ アクセプター {REST} {REST} {REST} {専用回線} {専用回線} 診断システムAPIゲートウェイ（クラスター化されたインスタンス群） 認証システム {REST} {REST} {REST} 看護師用 セルフ {REST} キュー サービス 用キュー コール 看護師 カルテ交換 診断エンジン 診断アウトブレイク 症例管理 ルーター プロフィール管理 インターフェイス インターフェイス キャッシュ {専用回線} {専用回線} 看護師 プロフィールDB 症例DB 外部サードパーティ 外部カルテ交換 診断エンジン 看護師プロフィール 症例メモ SLA: 99.9% SLA: 99.99% 可用性 可用性 図20-12 弾力性リスクに対応するためのアーキテクチャ変更 20.5.3 セキュリティ 最初の2回のリスクストーミングの結果と成功に勇気づけられたアーキテクトは、システムの 成功を確実にするためにシステムでサポートされなければならないもう1つの重要なアーキテク チャ特性であるセキュリティについて、最後のリスクストーミングセッションを開催することにし た。HIPAAの規制要件により、カルテ交換インターフェイスを介したカルテへのアクセスは安全 でなければならず、必要に応じて看護師のみがカルテにアクセスできるようにしなければならな い。アーキテクトは、APIゲートウェイのセキュリティチェック（認証と認可）により、これは問 20.5 リスクストーミング例 317 題ないと考えているものの、参加者が他のセキュリティリスクの要素を見つけたかどうかに興味を 持っている。 リスクストーミングでは、参加者全員が診断システムのAPIゲートウェイを高いセキュリティリ スク（6）として認識していた。この高い評価の根拠は、管理スタッフやセルフサービスの患者が カルテにアクセスすることによる影響の大きさ（3）と、中程度の可能性（2）の組み合わせによる ものだ。リスクが発生する可能性は、API呼び出しごとにセキュリティチェックが行われているた め高くは評価されなかったが、すべての呼び出し（セルフサービス、管理者、看護師）が同じAPI ゲートウェイを通過するため、中評価となった。アーキテクトは、リスクを低い（2）としか評価 していなかったが、リスクストーミングのコンセンサス活動の中で、実際にはリスクが高く、軽減 が必要であると確信した。 参加者は、ユーザー種類（管理者、セルフサービス／診断者、看護師）ごとに別々のAPIゲー トウェイを持つことで、管理者のWebユーザーインターフェイスやセルフサービス用のWebユー ザーインターフェイスからの呼び出しがカルテ交換インターフェイスに到達するのを防げるという ことに同意した。アーキテクトはこれに同意し、図20-13に示すような最終的なアーキテクチャを 作成した。 管理者向け 看護師向け セルフサービス用 コール UI UI Webアプリ アクセプター {REST} {REST} {REST} {REST} {専用回線} {専用回線} 管理者APIゲートウェイ 看護師APIゲートウェイ 診断APIゲートウェイ （クラスター化された （クラスター化された （クラスター化された 認証システム インスタンス群） インスタンス群） インスタンス群） {REST} {REST} {REST} 看護師用 セルフ {REST} キュー サービス用 キュー コール 看護師 カルテ交換 診断エンジン 診断アウトブレイク 症例管理 ルーター プロフィール管理 インターフェイス インターフェイス キャッシュ {専用回線} 専用回線 看護師 プロフィールDB 症例DB 外部サードパーティ 外部カルテ交換 診断エンジン 看護師プロフィール 症例メモ SLA: 99.9% SLA: 99.99% 可用性 可用性 図20-13 セキュリティリスクに対処するための最終的なアーキテクチャの変更 前述のシナリオは、リスクストーミングの威力を示している。システムの成功に欠かせないリス 318 20章 アーキテクチャ上のリスクを分析する クについて、他のアーキテクト、開発者、主要なステークホルダーと協力して取り組むことで、そ れまで気づかなかったリスク領域が特定できた。図20-9と図20-13を比較すると、リスクストー ミング前とリスクストーミング後のアーキテクチャに大きな違いがあることがわかる。この大きな 違いは、アーキテクチャにおける可用性、弾力性、セキュリティの懸念に対応することによって生 まれた。 リスクストーミングは、一度きりのプロセスではない。むしろ、システムの寿命を通じた継続的 なプロセスであり、本番環境でリスクが発生する前に捕捉して軽減するためのものだ。リスクス トーミングの取り組みをどれくらいの頻度で行うかは、変更の頻度、アーキテクチャのリファクタ リング作業、アーキテクチャのインクリメンタルな開発など、多くの要因に左右される。主要な機 能が追加された後や、すべてのイテレーションの終わりに、いくつかの側面に対してリスクストー ミングをするのが一般的だ。